import { ethers, network } from "hardhat";
import { expect } from "chai";

import type { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { ISetup__factory } from "../typechain-types";

import Challenges from "../challenges";

const { parseUnits } = ethers.utils;

import * as ForkHelpers from "./shared/forkHelpers";

describe("", () => {
  let owner: SignerWithAddress;

  beforeEach(async () => {
    if (network.name == "hardhat") {
      await ForkHelpers.forkToGoerli(6393690);
    }

    [owner] = await ethers.getSigners();
  });

  for (const item of Object.keys(Challenges)) {
    const { status, challenge, setup, deployValue, finalizeValue } =
      Challenges[item];

    const testMethod = status == "test" ? it.only : it;

    switch (status) {
      case "ready":
      case "test":
        testMethod(
          `solving ${item} (setup: ${setup}, challenge: ${challenge})`,
          async () => {
            const Exploit = await ethers.getContractFactory(`Exploit_${item}`);
            const setupContract = ISetup__factory.connect(setup, owner);

            if (!(await setupContract.isSolved())) {
              console.log(`${item} not solved. attempting`);
              let deployOpts = {};
              if (!!deployValue) {
                deployOpts = { value: parseUnits(deployValue) };
              }
              const exploit = await Exploit.deploy(challenge, deployOpts);

              let finalizeOpts = {};
              if (!!finalizeValue) {
                finalizeOpts = {
                  value: parseUnits(finalizeValue),
                  gasLimit: parseUnits("100"),
                };
              }
              await exploit.finalize(finalizeOpts);
            }

            expect(await setupContract.isSolved()).to.be.true;
          }
        );
        break;
      case "done":
        console.log(`${item} DONE`);
        break;

      default:
        console.log(`${item} exploit not yet ready. skipping`);
        break;
    }
  }
});
